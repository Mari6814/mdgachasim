import random
from dataclasses import dataclass, field
from typing import Dict, List, Set

from .card import Card, Rarity


@dataclass
class PullResult:
    cards: List[Card]
    finishes: List[int]
    materials: Dict[Rarity, int]
    pity: int


@dataclass
class Pack:
    # Name of the set
    name: str
    # All cards in the set
    cardlist: Set[Card] = field(default_factory=set)
    # Normal packs are always available, and all cards pulled are from that pack and not master pack.
    is_normal_pack: bool = False
    # Number of cards per rarity
    totals: Dict[Rarity, int] = field(default_factory=dict)
    # Each card sorted by rarity
    by_rarity: Dict[Rarity, Set[Card]] = field(default_factory=dict)

    def __repr__(self):
        return f"[Pack {self.name!r}]"

    def __post_init__(self):
        self.totals = {rarity: 0 for rarity in Rarity}
        self.by_rarity = {rarity: set() for rarity in Rarity}
        for card in self.cardlist:
            self.totals[card.rarity] += 1
            self.by_rarity[card.rarity].add(card)

    def __hash__(self):
        return hash(self.name)

    def __eq__(self, other):
        return isinstance(other, Pack) and other.name == self.name

    def __iter__(self):
        yield from self.cardlist

    def pull_ten(self, pity: int, master_pack: "Pack"):
        # List of cards pulled (may contain duplicates, order important)
        cards: List[Card] = []
        # ... and their associated finish value
        finishes: List[int] = []
        # Materials generated by dismantling unimplemented cards
        mats: Dict[Rarity, int] = {r: 0 for r in Rarity}
        # The decision to give an UR is triggered at the start
        # given the input pity counter
        trigger_pity = pity >= 10
        # A ten_pull consists of 10 packs with 8 cards each
        for pack_number in range(1, 11):
            did_draw_ur = False
            for card_number in range(1, 9):
                if card_number == 8:
                    if pack_number == 10:
                        # The last pack is special
                        if trigger_pity:
                            # Pity triggered on last cards in last pack:
                            # ultra guaranteed
                            weights = (1.0, 0.0, 0.0, 0.0)
                        else:
                            # Last pack has guaranteed SR or higher
                            weights = (0.2, 0.8, 0.0, 0.0)
                    else:
                        # Else R or better is guaranteed
                        weights = (0.025, 0.075, 0.9, 0.0)
                else:
                    # Any other pack as the usual distribution
                    weights = (0.025, 0.075, 0.35, 0.55)
                # Choose a rarity according to the distribution
                rarity = random.choices(
                    (Rarity.Ultra, Rarity.Super, Rarity.Rare, Rarity.Common),
                    weights=weights,
                )[0]
                if rarity == Rarity.Ultra:
                    # If it is an ultra rare, mark this pack as "has received an UR"
                    did_draw_ur = True
                    # Reset the 10 pack pity counter
                    pity = 0
                # Select a finish depending on the rarity
                if rarity in (Rarity.Super, Rarity.Ultra):
                    finish = random.choices((30, 15, 10), weights=(1, 9, 90))[0]
                else:
                    finish = random.choices((15, 10), weights=(10, 90))[0]
                # The first four cards are taken from master pack pool.
                # Normal packs do not mix with the master pack pool.
                # Only secret packs have some master pack pool cards.
                if not self.is_normal_pack and card_number <= 4:
                    possible_cards = master_pack.by_rarity[rarity]
                    totals = master_pack.totals[rarity]
                else:
                    possible_cards = self.by_rarity[rarity]
                    totals = self.totals[rarity]
                # Pick according to the distribution of implemented/not implemented cards
                if totals > 0 and random.random() < (len(possible_cards) / totals):
                    # An implemented cards is chosen at random
                    cards.append(random.choice(list(possible_cards)))
                    finishes.append(finish)
                else:
                    # An unimplemented card is dismantled immediately
                    mats[rarity] += finish
            # If this pack did not pull an UR:
            # increase the pity counter
            if not did_draw_ur:
                pity += 1
        return PullResult(cards, finishes, mats, pity)
